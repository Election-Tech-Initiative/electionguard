{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is ElectionGuard?","text":""},{"location":"#what-is-electionguard","title":"What is ElectionGuard?","text":"<p>ElectionGuard is an open source software development kit (SDK) that improves confidence and participation in elections. It is designed for election system vendors to incorporate end-to-end verifiability into their systems and any interested organization to perform and publish post-election audits.</p> <p>New to ElectionGuard?</p> <p>Welcome! Thanks for your interest. Trying to figure out how to help and learn? If you're a developer, head over to the developer getting started. If you want to help and aren't a developer, all kinds of help with documentation, outreach, and advocacy is welcomed. Follow discussions, join the office hours, and check out the roadmap to see where it's intended to go.</p>"},{"location":"#open-source","title":"Open-Source","text":"<p>This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard.</p>"},{"location":"#security-issues-reporting","title":"Security Issues Reporting","text":"<p>We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Help defend democracy and contribute to the project.</p> <p>We welcome discussions on our discussions page, feel free to check in and ask your questions and drop your suggestions regarding the specifications over there.</p>"},{"location":"#questions","title":"Questions","text":"<p>ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com.</p>"},{"location":"#thank-you","title":"Thank you","text":"<p>A huge thank you to those who have helped us along the way:</p> <ul> <li>Josh Benaloh (whose PhD thesis was the genesis of much of this work)</li> <li>Our contributors and community</li> <li>InfernoRed Technology</li> <li>Hart InterCivic</li> <li>MITRE</li> <li>Enhanced Voting</li> <li>VotingWorks</li> <li>Center for Civic Design</li> <li>Oxide Design</li> <li>Many teams within Microsoft</li> </ul>"},{"location":"Reports/E2EVerifiability/","title":"End-to-End Verifiability in Real World Elections","text":"<p>Check out our newly released report to the Election Assistance Commission.</p> <p>The report provides an overview of the ElectionGuard Pilot in the 2022 Franklin County General Election, and encourages the EAC to consider a different approach to demonstration of a successful e2e-v deployment in a real-world election.</p> <p></p>"},{"location":"concepts/Manifest_Building/","title":"Election Manifest","text":"<p>There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits).</p> <p>We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification (PDF) and the Civics Common Standard Data Specification.  The information captured by the NIST standard is codified into an <code>election manifest</code> that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles.</p> <p>ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process.  Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard.</p> <p>In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme.</p>"},{"location":"concepts/Manifest_Building/#election-data-structure","title":"Election Data Structure","text":"<p>Elections are characterized into types by NIST as shown in the table below:</p> election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. <p>We present two sample manifests: <code>general</code> and <code>partisan-primary-closed</code>. The core distinction between the two samples is the role of party: in general elections, voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries, voters can only vote in contests germane to their party declaration or affiliation. As such, <code>special</code>, <code>runoff</code>, and <code>primary</code> election types will follow the <code>general</code> pattern, and <code>partisan-primary-open</code> will follow the <code>partisan-primary-closed</code> pattern. Open <code>primary</code> elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an <code>open-primary-closed</code> election if a contest with an incorrect party affiliation were submitted (as indicated by the ).)</p>"},{"location":"concepts/Manifest_Building/#ballot-styles-and-geography","title":"Ballot Styles and Geography","text":"<p>At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and  jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines.  The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means.</p> <p>In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest.</p>"},{"location":"concepts/Manifest_Building/#geographic-and-ballot-style-breakdown","title":"Geographic and Ballot Style Breakdown","text":"<p>Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place.  The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below.</p> <p></p> <p>As the diagram shows, congressional,  state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use <code>precinct</code> but <code>ward</code> and <code>district</code> could be used instead.</p>"},{"location":"concepts/Manifest_Building/#contests-candidates-and-parties","title":"Contests, Candidates and Parties","text":"<p>In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them.  A contest is a specific collection of available choices (selections) from which the voter may choose some subset.  For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests.  If a contest also supports write-in values, then a write-in candidate is also defined.  Candidates may also be associated with specific parties, but this is not required for all election types.</p>"},{"location":"concepts/Manifest_Building/#introducing-hamilton-county-oz","title":"Introducing Hamilton County, OZ","text":"<p>To help disambiguate, let's explore an example.</p>"},{"location":"concepts/Manifest_Building/#geographic-jurisdictions","title":"Geographic Jurisdictions","text":"<p>Hamilton County includes 3 townships: LaCroix, Arlington, Harris.  The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts.  The county is also split into two congressional districts, district 5 and district 7.  Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7.</p> <p>]</p>"},{"location":"concepts/Manifest_Building/#building-the-geographic-jurisdiction-mapping-geopolitical-units","title":"Building the Geographic Jurisdiction Mapping (Geopolitical Units)","text":"<p>The Election Manifest includes an array of objects called <code>geopoliticalUnits</code> (a.k.a. gpUnit).  Each Geopolitical Unit must include the following fields:</p> <ul> <li>objectId - a unique identifier for the gpUnit.  This value is used to map a contest to a specific jurisdiction</li> <li>name - the friendly name of the gp Unit</li> <li>type - they type of jurisdiction (one of the Reporting Unit Types)</li> <li>contact information - the contact info for the geopolitical unit</li> </ul> <p>Geopolitical units are polygons on a map represented by legal jurisdictions.  In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above:</p> <ul> <li>Hamilton County</li> <li>Congressional District 5</li> <li>congressional District 7</li> <li>LaCroix Township</li> <li>Exeter Utility District (within LaCroix Township)</li> <li>Harris Township</li> <li>Arlington Township</li> <li>Pismo Beach School District (within Arlington Township)</li> <li>Somerset School District (within Arlington Township)</li> </ul> <p>When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction.  This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units.  Alternatively, you can define only the GP Units for which there are contests.</p>"},{"location":"concepts/Manifest_Building/#the-general-election-contests","title":"The General Election Contests","text":"<p>A general election will occur in Hamilton County.  The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results.  This means that the Election Scope is defined at the county level.</p> <p>For the <code>general</code> election, the following sets of contests (and associated geographic boundaries) obtain:</p> <ol> <li>The National Contests - President and Vice President.  This contest demonstrates a \"vote for the ticket\" and allows write-ins</li> <li>Province Contests - Governor - this contest demonstrates a long list of candidate names</li> <li>Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles</li> <li>Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles</li> <li>School District Contests - School Board - these contests demonstrate contests with multiple selections (n-of-m) and allow write-ins School Board, and Utility district referendum to show ballot style splits</li> <li>Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish</li> </ol> <p>Each contest must be associated with exactly ONE <code>electoralDistrictId</code>.  The <code>electoralDistrictId</code> field on the contest is populated with the <code>objectId</code> of the associated Geopolitical Unit (e.g. the Contest <code>congress-district-7-contest</code> has the <code>electoralDistrictId</code> <code>congress-district-7</code></p> <p>Each contest must also define a <code>sequenceOrder</code>.  the sequence order is an indexing mechanism used internally.  It is not the sequence that the contests are displayed to the user.  The order in which contests are displayed to the user is up to the implementing application.</p>"},{"location":"concepts/Manifest_Building/#the-general-election-ballot-styles","title":"The General Election Ballot Styles","text":"<p>A ballot style is the set of contests that a specific voter should see on their ballot for a given location.  The ballot style is associated to the set of geopolitical units relevant to a specific point on a map.  Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point.</p> <p>For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District.  </p> <p>| Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map.</p> <p>Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system:</p> <ul> <li>Congressional District 7 Outside Any Township</li> <li>Congressional District 7 LaCroix Township</li> <li>Congressional District 7 LaCroix Township Exeter Utility District</li> <li>Congressional District 7 Arlington Township</li> <li>Congressional District 7 Arlington Township Pismo Beach School district</li> <li>Congressional District 7 Arlington Township Somerset School district</li> <li>Congressional District 5 Outside Any Township</li> <li>Congressional District 5 LaCroix Township</li> <li>Congressional District 5 Harris Township</li> <li>Congressional District 5 Arlington Township Pismo Beach School district</li> <li>Congressional District 5 Arlington Township Somerset School district</li> </ul> <p>By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct.  We do not have to modify the list of geopolitical units or ballot styles.</p>"},{"location":"concepts/Manifest_Building/#data-flexibility","title":"Data Flexibility","text":"<p>The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application.  This example is just one way to define this relationship that is purposefully verbose.  For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point.  This is a top-down approach.  Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1.</p> <p>for instance, instead of defining a single GP Unit each for:</p> <ul> <li>Congressional District 5,</li> <li>Congressional District 7,</li> <li>LaCroix Township,</li> <li>Exeter Utility district, etc;</li> </ul> <p>we could have instead defined the GP Units as:</p> <ul> <li>Congressional District 5 No Township</li> <li>Congressional District 7 No Township</li> <li>Congressional District 5 inside LaCroix</li> <li>Congressional District 5 Inside LaCroix and Exeter, etc.</li> </ul> <p>Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit.</p>"},{"location":"concepts/Manifest_Building/#data-validation","title":"Data Validation","text":"<p>When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that:</p> <ul> <li>Each Geopolitical Unit has a unique objectId</li> <li>Each Ballot Style maps to at least one valid Geopolitical Unit</li> <li>Each Party has a unique objectId</li> <li>Each Candidate either does not have a party, or is associated with a valid party</li> <li>Each Contest has a unique Sequence Order</li> <li>Each Contest is associated with exactly one valid Geopolitical Unit</li> <li>Each Contest has a valid number of Selections for the number of seats in the contest</li> <li>Each Selection on each Contest is associated with a valid Candidate</li> </ul> <p>as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election.</p>"},{"location":"concepts/Manifest_Building/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this.  In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit.  for instance, if <code>ballot-style-1</code> includes <code>contest-1</code> then you may create <code>geopolitical-unit-1</code> and associate both the ballot style and the contest to that geopolitical unit.</p> <p>This documentation is under review and subject to change.  Please do not hesitate to open a github issue if you have questions, or find errors or omissions.</p>"},{"location":"concepts/Structure_and_Processes/","title":"Structure and Processes","text":"<p>ElectionGuard provides tools to enable end-to-end verifiable elections. This allows voters to check for themselves that their votes have been accurately counted.</p> <p>The ElectionGuard process has three principal components.</p> <ul> <li>Pre-election key generation</li> <li>Ballot encryption</li> <li>Post-election decryption of tallies</li> </ul>"},{"location":"concepts/Structure_and_Processes/#pre-election-key-generation","title":"Pre-Election Key Generation","text":"<p>ElectionGuard utilizes Guardians to protect confidentiality of ballots. The Guardians independently generate public-private key pairs from public election parameters.</p>     flowchart TD     A(\"Guardian T<sub>1</sub>(K<sub>1</sub>,S<sub>1</sub>)\")--&gt;B(K<sub>1</sub>);     C(\"Guardian  T<sub>2</sub>(K<sub>2</sub>,S<sub>2</sub>)\")--&gt;D(K<sub>2</sub>);     E(\"Guardian  T<sub>n</sub>(K<sub>n</sub>,S<sub>n</sub>)\")--&gt;F(K<sub>n</sub>);     style B fill:#FFFFFF00,stroke:#FFFFFF00     style D fill:#FFFFFF00,stroke:#FFFFFF00     style F fill:#FFFFFF00,stroke:#FFFFFF00  <p>The individual public keys are then combined to form the election public key using simple multiplication.</p> \\[ K=\\prod_{i=1}^{n} K_i \\] <p>At this point in the process, the only way to decrypt data encrypted with the election public key K is for all n Guardians to individually apply their secret keys. This situation is fragile since a single missing Guardian will prevent an election from being completed. To remedy this, as the final pre-election step, the Guardians distribute to each other shares of their private keys. The sharing is done according to a pre-determined quorum parameter k and will allow any quorum set of k Guardians to complete a decryption.</p>     graph LR     A(\"Guardian  T<sub>1</sub>(K<sub>1</sub>,S<sub>1</sub>)\")--&gt;|S<sub>1,2</sub>|B(\"Guardian  T<sub>2</sub>(K<sub>2</sub>,S<sub>2</sub>)\");     B--&gt;|S<sub>2,1</sub>|A;     A--&gt;|S<sub>1,n</sub>|C(\"Guardian  T<sub>n</sub>(K<sub>n</sub>,S<sub>n</sub>)\");     B--&gt;|S<sub>2,n</sub>|C;     C--&gt;|S<sub>n,2</sub>|B;     C--&gt;|S<sub>n,1</sub>|A;"},{"location":"concepts/Structure_and_Processes/#balot-encryption","title":"Balot Encryption","text":"<p>An encrypted ballot consists entirely of encryptions of zeros and ones.</p> <p>A simple clear form ballot with a single contest might look something like the following.</p> \\[ \\braket{{\\color{RoyalBlue} 0,1,0,0}} \\] <p>This would represent a ballot with a single contest in which the second of four options has been selected.</p> <p>The encrypted version of this ballot would consist of four encrypted values</p> \\[ \\braket{C_1,C_2,C_3,C_4} \\] <p>accompanied by \"proofs\" that each W_i is an encryption of either zero or one.</p> <p>But this is not enough to show that an encrypted ballot represents a legitimate vote because the clear form might be as follows.</p> \\[ \\braket{{\\color{RoyalBlue} 0,1,0,1}} \\] <p>The above ballot would indicate votes for both the second and fourth options, and this may not be allowed.</p> <p>To address this, we use the homomorphic property of the encryption which allows us to combine encryptions to produce an encryption of the sum. By using simple encryption, we can form a new encrypted value as</p> \\[ C=\\prod_{i=1}^{4} C_i \\] <p>and include a proof that this W is an encryption of one to show that the ballot doesn\u2019t include excessive votes.</p>"},{"location":"concepts/Structure_and_Processes/#placeholders","title":"Placeholders","text":"<p>This isn\u2019t quite everything we need, because a voter might choose to not vote in a contest. The resulting clear form of this ballot would look like the following.</p> \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0}} \\] <p>If we were to homomorphically combine values in an encrypted form of this ballot, we would get an encryption of zero \u2013 not an encryption of one. We wouldn\u2019t want to reveal this fact, because even a voter who chooses not to vote deserves privacy.</p> <p>To address this, we add a placeholder option to each contest that can be thought of as a \"none of the above\" vote. So a contest with four options would be typically be represented by a ballot with five positions \u2013 with the fifth option set to one if the voter selects none of the four options offered.</p> \\[   \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\] [Color changes are for exposition only.] <p>Internally, a placeholder option looks no different from an ordinary option. But we can now ensure that a homomorphic combination of all of the encryptions on a ballot will be one.</p> <p>An encrypted ballot can now be shown to be legitimate by proving that each value is an encryption of either zero and one and the homomorphic combination of all of the encryptions in each contest is an encryption of one.</p> \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\longrightarrow {\\color{DarkBlue} 1} \\] <p>Some might recognize this as a \"map-reduce\" operation (or for those familiar with Kenneth Iverson's APL, a simple reduction operation). The operator applied to encrypted values is simple multiplication. But the effect is to produce an encryption of the sum of the clear form values.</p>"},{"location":"concepts/Structure_and_Processes/#selection-limits","title":"Selection Limits","text":"<p>There is one further generalization that must be accommodated. In some elections, there are contests where a voter is allowed to select more than one option. For example, there might be five options of which a voter is allowed to select up to three.</p> <p>To accommodate this possibility, we note the selection limit for each contest and generalize the use of placeholders. In most elections, all or most contests will have a selection limit of one, and one placeholder option will be added to each such contest. However, if the selection limit is higher, additional placeholder values are added \u2013 with the total number of placeholders matching the selection limit.</p> <p>For example, a \"choose up to three of five\" contest will be captured with eight encrypted values, the first five of which match the selections that can be made by a voter, and the last three of which are placeholder values that can be set if a voter does not make the maximum number of selections.</p> <p>The following offers some examples of how the clear form of a choose three of five ballot might be set.</p> \\[\\begin{align}     \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\     \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\     \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}}\\longrightarrow {\\color{DarkBlue}3} \\\\     \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\     \\braket{{\\color{RoyalBlue}0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\end{align}\\] [Color changes are for exposition only.] <p>The first two instance represent ballots in which all three allowed votes have been used; the next instance shows a ballot in which only two options were selected; the following ballot instance contains one selection (and two placeholders set); and the final instance shows a case when a voter has made no selections and all three placeholders are used.</p> <p>In all of the above examples, an associated encrypted ballot is shown to be legitimate by showing that every value is an encryption of zero or one and the homomorphic combination of all of the encryptions produces an encryption of three.</p>"},{"location":"concepts/Structure_and_Processes/#write-in-votes","title":"Write-in Votes","text":"<p>ElectionGuard currently does not distinguish between write-ins. If a write-in option is offered, ElectionGuard treats it as any other selection. ElectionGuard tallies the number of write-ins for any contest without indicating what was written in.</p>"},{"location":"concepts/Structure_and_Processes/#multiple-contests","title":"Multiple Contests","text":"<p>Most elections consist of more than a single contest. A single ballot can therefore include multiple contests. An encrypted ballot still consists entirely of encryptions of zeros and ones, but the interpretation of these encryptions and the accompanying proofs depend upon details provided in the ballot manifest.</p> \\[ \\braket{{\\color{RoyalBlue} 0,1,0,}{\\color{SkyBlue} 0};{\\color{ForestGreen} 1,0,}{\\color{YellowGreen} 0};{\\color{RoyalBlue} 0,0,}{\\color{SkyBlue} 1};{\\color{ForestGreen} 1,0,1,0,0,}{\\color{YellowGreen} 0,0,1}} \\] [Color changes are for exposition only.] <p>The above example shows a clear form of a ballot with four contests in which the second of three options is selected in the first contest (with the fourth position as an unused placeholder), the first of two options is chosen in the second contest (with the third position as an unused placeholder), neither of two options is selected in the third contest (with the placeholder set to one), and the first and third option selected in a \"three of five\" fourth contest with one of three placeholders set to one.</p> <p>The encrypted form of the example above should be accompanied by proofs that all eighteen of the components are encryptions of zero or one, that the first four encryptions homomorphically combine to form an encryption of one, the next three encryptions homomorphically combine to form an encryption of one, the following three encryptions homomorphically combine to form an encryption of one, and the final eight encryptions homomorphically combine to form an encryption of three.</p>"},{"location":"concepts/Structure_and_Processes/#post-election-decryption-of-tallies","title":"Post-Election Decryption of Tallies","text":"<p>When an election is complete, there will be a set of encrypted ballots that have been cast by voters and will be published in the election record.</p> <p>The homomorphic property that is used within individual ballots to show that the number of selected options for each contest is correct can also be used across ballots to compute tallies.</p> <p>For example, suppose that the five clear form ballots shown above as samples in a choose-three-of-five contest represent actual ballots cast in an election.</p> \\[\\begin{align}     \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue} 0,0,0}} \\\\     \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue} 0,0,0}} \\\\     \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}} \\\\     \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\\\     \\braket{{\\color{RoyalBlue} 0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\\\     \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\\\     \\braket{{\\color{RoyalBlue} 2,1,1,3,2,}{\\color{SkyBlue} 1,2,3}} \\\\ \\end{align}\\]"},{"location":"concepts/Structure_and_Processes/#verifiable-decryption","title":"Verifiable Decryption","text":"<p>Guardians can each apply their private keys to an encrypted value to perform a partial decryption.</p>     graph TD     A(\"Guardian  T<sub>1</sub>(K<sub>1</sub>,S<sub>1</sub>)\")--&gt;B(M<sub>1</sub>);     C(\"Guardian  T<sub>2</sub>(K<sub>2</sub>,S<sub>2</sub>)\")--&gt;D(M<sub>2</sub>);     A1(C)--&gt;A;     C1(C)--&gt;C;     E(\"Guardian T<sub>n</sub>(K<sub>n</sub>,S<sub>n</sub>)\")--&gt;F(M<sub>n</sub>);     E1(C)--&gt;E;     style B fill:#FFFFFF00,stroke:#FFFFFF00     style D fill:#FFFFFF00,stroke:#FFFFFF00     style C1 fill:#FFFFFF00,stroke:#FFFFFF00     style A1 fill:#FFFFFF00,stroke:#FFFFFF00     style E1 fill:#FFFFFF00,stroke:#FFFFFF00     style F fill:#FFFFFF00,stroke:#FFFFFF00  <p>The partial decryptions \\(M_i\\) can be combined \u2013 again using ordinary multiplication \u2013 to form the full decryption.</p> \\[ M = \\prod _{i=1} ^n M_i \\] <p>Together with each partial decryption, each guardian produces additional data that can be used by observers to very that the decryptions are correct.</p>"},{"location":"concepts/Structure_and_Processes/#missing-guardians","title":"Missing Guardians","text":"<p>If one or more Guardians are missing during a decryption, a quorum of any \\(k\\) available Guardians can form the partial decryption of the missing Guardian.</p>     graph TD     A(\"Guardian  T<sub>i<sub>1</sub></sub>S<sub>j,i<sub>1</sub></sub>\")--&gt;B(M<sub>j,i<sub>1</sub></sub>);     C(\"Guardian  T<sub>i<sub>2</sub></sub>S<sub>j,i<sub>2</sub></sub>\")--&gt;D(M<sub>j,i<sub>2</sub></sub>);     A1(C)--&gt;A;     C1(C)--&gt;C;     E(\"Guardian T<sub>i<sub>k</sub></sub>S<sub>j,i<sub>k</sub></sub>\")--&gt;F(M<sub>j,i<sub>k</sub></sub>);     E1(C)--&gt;E;     style B fill:#FFFFFF00,stroke:#FFFFFF00     style D fill:#FFFFFF00,stroke:#FFFFFF00     style C1 fill:#FFFFFF00,stroke:#FFFFFF00     style A1 fill:#FFFFFF00,stroke:#FFFFFF00     style E1 fill:#FFFFFF00,stroke:#FFFFFF00     style F fill:#FFFFFF00,stroke:#FFFFFF00  <p>The \\(k\\) values \\(M_{j,i_{1}},M_{j,i_{2}}, ... ,M_{j,i_{k}},\\) can be combined to calculate the missing partial decryption. In this way, an aggregate ballot can be fully and verifiably decrypted by any quorum set of \\(k\\) Guardians.</p>"},{"location":"concepts/Structure_and_Processes/#casting-and-spoiling","title":"Casting and Spoiling","text":"<p>Voters need to be provided with a mechanism to encrypt their selections and have confidence that their selections have been correctly encrypted. The process used by ElectionGuard is to encrypt ballots as instructed by voters and then to allow voters to optionally spoil encrypted ballots. A spoiled ballot is verifiably decrypted (as with the aggregate ballot above), and the voter is given the opportunity to cast a new ballot.</p>     graph TD     id[Make Selections]--&gt;id1[Have Ballot Encrypted];     id1--&gt;id2[Choose Cast or Spoil];     id2--&gt;|Cast| id3[Record Encrypted Ballot as Cast];     id2--&gt;|Spoil| id4[Decrypt Ballot and Record it as Spoiled];     id4--&gt;id;"},{"location":"concepts/Structure_and_Processes/#the-election-record","title":"The Election Record","text":"<p>Once voting is complete, an election record is published containing all of the following artifacts.</p> <ul> <li>All cast encrypted ballot</li> <li>Proofs that all cast encrypted ballots are properly formed</li> <li>A tally ballot formed as the homomorphic aggregation of all cast ballots</li> <li>A verifiable decryption of the tally ballot</li> <li>All spoiled ballots</li> <li>Verifiable decryptions of all spoiled ballots</li> </ul> <p>Cast Ballots:</p> Contest1 Contest2 Contest3 Encrypted Ballot 1 Proof of Correct Form Encrypted Ballot 2 Proof of Correct Form Encrypted Ballot 3 Proof of Correct Form Encrypted Ballot 4 Proof of Correct Form Encrypted Ballot 5 Proof of Correct Form Encrypted Ballot 6 Proof of Correct Form xxxx xxxx xxxx Encrypted Tally Decrypted Tally 312123 022113 Proof of Correct Decryption <p>Spoiled Ballot 1:</p> Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0100 1000 0001 Proof of Correct Decryption <p></p> <p>Spoiled Ballot 2:</p> Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1000 0011 1000 Proof of Correct Decryption <p></p> <p>Spoiled Ballot 3:</p> Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1000 0001 0001 Proof of Correct Decryption <p></p> <p>Spoiled Ballot 4:</p> Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0010 0100 0100 Proof of Correct Decryption"},{"location":"concepts/Structure_and_Processes/#verification","title":"Verification","text":"<p>Voters are able to verify that their own ballots have been correctly recorded by utilizing the ballot spoiling process described above. Anyone can verify that recorded ballots have been accurately tallied by verifying the following items.</p> <ul> <li>For each cast ballot, the proof that the ballot is properly formed</li> <li>The tally ballot is the homomorphic aggregation of all cast ballots</li> <li>The proof that the aggregate tally ballot has been correctly decrypted</li> </ul> <p>In addition, the election record contains spoiled ballots for which the following should be verified.</p> <ul> <li>The proof of the correct decryption of each spoiled ballot</li> <li>Each spoiled ballot is properly formed (this can be done by checking proofs of proper formation or simply by inspecting the decryption)</li> </ul> <p>Although logically, the verification of correct decryption of spoiled ballots can be done by the individual voters who spoiled those ballots as part of the verification of correct recording; practically, this process closely matches the process of verifying correct decryption of the aggregate tally ballot. By transferring this responsibility to those verifying the election record, voters who want to verify correct recording of their ballots can be relieved of the responsibility of writing/executing code to check the decryption arithmetic and can instead check merely whether the claimed decryptions of spoiled ballots match their expectations.</p>"},{"location":"concepts/Verifiability/","title":"Creating a Verifiable Election","text":"<p>ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections.  Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered:</p> <ul> <li>The voter is given a <code>verification code</code> they can use to verify their ballot was included in the final tally</li> <li>The voter has the means to <code>challenge a ballot</code></li> <li>The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable <code>full independent verifiability</code> by third parties</li> </ul> <p>We describe each of these capabilities in detail below.</p>"},{"location":"concepts/Verifiability/#voter-verification-code","title":"Voter Verification Code","text":"<p>A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has <code>submitted their ballot</code> to the voting system.  </p>"},{"location":"concepts/Verifiability/#generating-the-verification-code","title":"Generating the Verification Code","text":"<p>Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system.</p> <p>From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot).  In the ballot marking device use case, the ballot would be encrypted after the voter presses submit.</p> <p></p> <p>For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot.</p> <p></p> <p>Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment.</p> <p>Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them.  When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below))</p> <p></p> <p>The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly).</p>"},{"location":"concepts/Verifiability/#challenging-a-ballot","title":"Challenging a ballot","text":"<p>Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to <code>challenge</code> or \"spoil\" the ballot after the verification code has been generated and provided to the voter.</p> <p>When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot.</p> <p>In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter.</p> <p>Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish.  Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct.</p>"},{"location":"concepts/Verifiability/#publishing-verifiable-results","title":"Publishing Verifiable results","text":"<p>When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently.</p> <p>E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification. Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec:</p> <p>An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote:</p> <ol> <li>The encryption associated with each option is either an encryption of zero or an encryption of one.</li> <li>The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one).</li> </ol> <p>ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive.  Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one.  The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof.</p> <p>Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option.  The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct.</p>"},{"location":"concepts/Verifiability/#showing-verification-code-results-to-voters","title":"Showing Verification Code Results to Voters","text":"<p>In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code.</p> <p>Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above).</p> <p>Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.</p>"},{"location":"contribute/","title":"Contribute","text":"<p>Whenever possible and as a guiding principle, the evolution of the ElectionGuard SDK will be driven by the use cases and priorities of the community and in service of best-practice implementations of real-world, secret-ballot public elections. Community contributions are highly valued. Help defend democracy and contribute to ElectionGuard.</p> <p></p>"},{"location":"contribute/#where-to-start","title":"Where to Start?","text":"<p>There are many locations to contribute to ElectionGuard. ElectionGuard is an open source platform and depends on an active community and ecosystem.</p> <p>The SDK is comprised of two repositories:</p> <ul> <li>ElectionGuard Specification</li> <li>ElectionGuard C++</li> </ul>"},{"location":"contribute/#ways-to-get-involved","title":"Ways to get involved","text":"<ol> <li>Learn about ElectionGuard and share the information</li> <li>Post questions or ideas in our discussion board</li> <li>Develop on issues in the repos with tags of good first issue or help wanted</li> <li>Add to and improve documentation. Keep it Plain English and include helpful images.</li> </ol>"},{"location":"contribute/#contributions","title":"Contributions","text":"<p>ElectionGuard relies on its community for its success. For example, for end-to-end verifiable elections, integrity is improved by the number of independent verifiers that confirm the results of an election.</p>"},{"location":"contribute/#verifiers","title":"Verifiers","text":"<ul> <li> Go Verifier by Andreas Nielsen, Niklas Bille, and Hans-Christian Kjeldsen</li> <li> Julia Verifier by MITRE</li> <li> Python Verifier by Rainbow Huang</li> <li> C# Verifier by Brandon Alexander</li> <li> Java Verifier by John Caron</li> <li> Python Verifier (electionguard-verify) by Nicholas Boucher</li> </ul>"},{"location":"contribute/#library-ports","title":"Library Ports","text":"<ul> <li> Java port of Python Library by John Caron</li> </ul>"},{"location":"develop/Applications/","title":"Applications","text":"<p>There are many different paths for creating applications that work using ElectionGuard. For many of these paths, there are reference implementations that can be forked or used as examples or used as packages. Many reference implementations include packaging or containerization for easy consumption. Below are some examples of paths a developer could take when developing using ElectionGuard. This list is by no means complete and some of these paths can be combined for different applications and use cases. </p> <p>If you develop an app for ElectionGuard, we suggest you utilize our badges to indicate which version of the specification your application targets. </p>"},{"location":"develop/Applications/#paths","title":"Paths","text":""},{"location":"develop/Applications/#electionguard-core","title":"ElectionGuard Core","text":"<p>An ElectionGuard Core is an application that implements the base level features such as Ballot Encryption by implementing them according to the specification. The internal examples of this are the Python and C++ reference implementations. There is a community example of this with the Java port done by the community. </p>"},{"location":"develop/Applications/#ballot-marking","title":"Ballot Marking","text":"<p>Ballot marking is the process of recording a voter's selections on a ballot. A ballot marking app displays the contests from the manifest according to an individuals voter's ballot style and language. The voter then votes and the selections are recorded on a plaintext ballot. </p>"},{"location":"develop/Applications/#ballot-encryption","title":"Ballot Encryption","text":"<p>Ballot encryption is the process of converting voter selections into data such that it cannot be read by unauthorized parties. A ballot encryption app provides this fundamental functionality. The app functions as a tool that encrypts a plaintext ballot into a encrypted ballot aka ciphertext ballot. </p> <p>Two quick ways to start are by using the ElectionGuard encryption nuget package or or python package.</p>"},{"location":"develop/Applications/#ballot-box","title":"Ballot Box","text":"<p>A ballot box app takes the encrypted ballot of a voter and allows a user to submit the ballot as cast or spoil the ballot. A submitted cast ballot is aggregated into the tally. A submitted spoiled ballot is added to the list of spoiled ballots. </p>"},{"location":"develop/Applications/#administer-election","title":"Administer Election","text":"<p>Administering an election for ElectionGuard usually requires the following steps. An example of this is available in electionguard-ui repository.</p> <ol> <li>Setup Election - An election should be setup with a manifest and selected guardians</li> <li>Key Ceremony - A key ceremony should be run that results in the encryption key that can be used for the ballots.</li> <li>Tally Ceremony - A tally ceremony when run will decrypt the tally and any spoiled ballots</li> <li>Election Record - An election record should be retrievable at the end of the election for publication and verification purposes. </li> </ol> <p>A quick way to start is to use the electionguard api-client and the electionguard-python-api.</p>"},{"location":"develop/Applications/#publish-election","title":"Publish Election","text":"<p>The results of election can be displayed after an election is closed. An example of this is available in electionguard-ui repository. This application should contain three pieces. </p> <ol> <li>Results - Using decrypted tally and manifest, the tallied results should be displayed. </li> <li>Ballot Confirmation - Confirm a ballot is in the Election Record.<ul> <li>Confirm Cast - Confirm a ballot was cast and included in tally</li> <li>Challenge Ballot - Confirm a ballot was spoiled and display decrypted spoiled ballot to user</li> </ul> </li> <li>Download Election Record - The Election Record should be downloadable for the public. </li> </ol>"},{"location":"develop/Applications/#verify-election","title":"Verify Election","text":"<p>A verifier app verifies an election is true and accurate by using the publicly published information about a completed election. At the close of an election using ElectionGuard, an election record should be created and made public. ElectionGuard encourages third parties to create their own verifiers and help verify election records. A basic example of a verifier can be found within the electionguard-python repository, but  verifiers should aim to be as thorough as possible. After consuming the files in an election record, verifiers can validate everything from the key ceremony to the decryption since the election is end to end verifiable. </p>"},{"location":"develop/Badges/","title":"Badges","text":"<p>For your convenience, these are some badges to add to your repository indicating the version of ElectionGuard your code supports. See versioning.</p> <p> <pre><code>[![ElectionGuard 0.85](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v0.85-red)](https://www.electionguard.vote/spec)\n</code></pre></p> <p> <pre><code>[![ElectionGuard 0.95](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v0.95-yellow)](https://www.electionguard.vote/spec)\n</code></pre></p> <p> <pre><code>[![ElectionGuard 1.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v1.0-green)](https://www.electionguard.vote/spec)\n</code></pre></p> <p> <pre><code>[![ElectionGuard 1.1](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v1.1-green)](https://www.electionguard.vote/spec)\n</code></pre></p> <p> <pre><code>[![ElectionGuard 2.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v2.0-green)](https://www.electionguard.vote/spec)\n</code></pre></p> <p> <pre><code>[![ElectionGuard 2.1](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v2.1-green)](https://www.electionguard.vote/spec)\n</code></pre></p>"},{"location":"develop/Data_Schema/","title":"Data Schema","text":"<p>ElectionGuard expects data to be formatted in a particular way according to a set of JSON schemas. The expectation is to keep these schemas alongside the specification. The schemas will be defined here to indicate to developers what they should be expecting.</p> <p>Keep in mind that not all serialized files should be public. The election record includes the list of all data formats that should be public. Sample data for the election is also available for developers. This will include both what is in the Election Record, but also some private data only available for testing. </p>"},{"location":"develop/Data_Schema/#schema-version-191shield-green-191","title":"Schema ![Version 1.91][shield-green-1.91]","text":"<p>Currently, JSON is used as the primary serialization format of the artifacts from an election. These are JSON schema files that can be used to verify the schema of the setup files like the manifest pre-election and the election record files post-election. This represents the full list of items that can be serialized / deserialized, but not all elections will use every file type. </p> <p>Work in Progress</p> <p>This is a work in progress. Feel free to contribute.</p>"},{"location":"develop/Data_Schema/#election","title":"Election","text":"<ul> <li>Manifest / <code>Manifest</code> - Election manifest</li> <li>Context / <code>CiphertextElectionContext</code> - Context for encryption for specific election</li> <li>Constants / <code>ElectionConstants</code>- Constants of election</li> <li>Encryption Device / <code>EncryptionDevice</code> - Encryption device information</li> </ul>"},{"location":"develop/Data_Schema/#ceremony","title":"Ceremony","text":"<ul> <li>Guardian / <code>GuardianRecord</code> - Single guardian's record</li> <li>Lagrange Coefficients / <code>LagrangeCoefficientsRecord</code> - Lagrange coefficients</li> </ul>"},{"location":"develop/Data_Schema/#ballot","title":"Ballot","text":"<ul> <li>Ballot / <code>PlaintextBallot</code> - Plaintext ballot</li> <li>[Compact Ballot][compact_ballot] / <code>CompactBallot</code> - Compact ballot</li> <li>Encrypted Ballot / <code>CiphertextBallot</code> - Encrypted ballot</li> <li>Spoiled Ballot / <code>SpoiledBallot</code> -  Submitted spoiled ballot</li> </ul>"},{"location":"develop/Data_Schema/#tally","title":"Tally","text":"<ul> <li>Tally / <code>PlaintextTally</code> - Plaintext tally</li> <li>Encrypted Tally / <code>PublishedCiphertextTally</code> - Encrypted tally</li> </ul>"},{"location":"develop/Election_Record/","title":"Election Record","text":""},{"location":"develop/Election_Record/#election-record","title":"Election Record","text":"<p>The Election Record is the group of files required at the end of the election to verify the election and is intended to be posted publicly. It should not contain any sensitive data (eg: no guardian private keys) in the record. These include the following:</p> <ul> <li>Encryption Devices Information</li> <li>Guardian Records</li> <li>Decrypted Spoiled Ballots</li> <li>Encrypted Submitted Ballots</li> <li>Lagrange Coefficients Record</li> <li>Election Constants</li> <li>Election Context</li> <li>Encrypted Tally</li> <li>Manifest</li> <li>Decrypted Tally</li> </ul>"},{"location":"develop/Election_Record/#folder-structure","title":"Folder Structure","text":"<p>The Election Record should be expected to be a zip folder containing the following information. </p> <pre><code>\ud83d\udcc2 record\n--- \ud83d\udcc1 encryption_devices\n------- \ud83d\udcc4 device_id_1.json\n------- \ud83d\udcc4 device_id_2.json\n------- ...\n--- \ud83d\udcc1 guardians\n------- \ud83d\udcc4 guardian_id_1.json\n------- \ud83d\udcc4 guardian_id_2.json\n------- ...\n--- \ud83d\udcc1 spoiled_ballots\n------- \ud83d\udcc4 spoiled_ballot_id_3.json\n------- \ud83d\udcc4 spoiled_ballot_id_4.json\n------- ...\n--- \ud83d\udcc1 submitted_ballots\n------- \ud83d\udcc4 submitted_ballot_id_1.json\n------- \ud83d\udcc4 submitted_ballot_id_2.json\n------- ...\n--- \ud83d\udcc4 coefficients.json\n--- \ud83d\udcc4 constants.json\n--- \ud83d\udcc4 context.json\n--- \ud83d\udcc4 encrypted_tally.json\n--- \ud83d\udcc4 manifest.json\n--- \ud83d\udcc4 tally.json\n</code></pre>"},{"location":"develop/Getting_Started/","title":"Getting Started","text":"<p>ElectionGuard as an SDK provides a specification and reference implementations with specific data format. If you're looking to develop code with ElectionGuard, you might be wondering where to start. There are two paths:</p> <ol> <li>Create an app using ElectionGuard</li> <li>Contribute to ElectionGuard's open source</li> </ol> <p>Tip</p> <p>If you're having trouble understanding where to start, take a look at versioning to get a good idea of what is still in progress.</p>"},{"location":"develop/Getting_Started/#create-an-app","title":"Create an App","text":"<p>There are many different possible applications that can be created using ElectionGuard reference implementations or for ElectionGuard. A helpful starting list can be found within applications. Feel free to use badges to indicate which version of the specification the app was developed for. </p>"},{"location":"develop/Getting_Started/#contribute-to-open-source","title":"Contribute to Open Source","text":"<p>ElectionGuard is an open source platform and depends on an active community and ecosystem. The contribute page highlights some top level ways to contribute. For those that want to jump right in, take a look at our repositories.</p> <p>Note</p> <p>Each repository houses the in-depth developer documentation for coding with the repositories.</p> <p></p>"},{"location":"develop/Repositories/","title":"Repositories","text":"<p>There are 5 repositories within the ElectionGuard SDK:</p> <ul> <li>ElectionGuard Specification</li> <li>ElectionGuard Python</li> <li>ElectionGuard C++</li> <li>ElectionGuard Python API</li> <li>ElectionGuard React UI</li> </ul> <p>If you're looking to develop for ElectionGuard, it might help if you pick something you're familiar with. The following list acts to showcase the language to assist you in finding the right place. Each repository contains information on the best way to contribute and how to setup the development environment. Take a look and see what appeals to you.</p>"},{"location":"develop/Repositories/#electionguard-specification","title":"ElectionGuard Specification   <p>The ElectionGuard Specification repository addresses the mathematical and conceptual underpinnings of end-to-end verifiability in a manner that comfortably accommodates post-election audits. The specification houses the core data constructs, tests, and datasets that we recommend to ensure portability and data integrity.</p> <p>The ElectionGuard site is also built from this repository using mkdocs. This can be a friendly place to start out for new developers trying to get started.</p> <p> Specification |  Source</p>","text":""},{"location":"develop/Repositories/#electionguard-python","title":"ElectionGuard Python   <p>The ElectionGuard Python library is a reference implementation of the ElectionGuard SDK. It covers the entire suite of functionality and processes necessary to implement an end-to-end verifiable election as part a voting system:</p> <ul> <li>Key generation ceremony</li> <li>Ballot encryption</li> <li>Tally ceremony</li> <li>Ballot decryption</li> </ul> <p>It is designed to be portable over performant, universal over Pythonic (although we do try to adhere to the Zen of Python).</p> <p>Any real-world voting use case will need to incorporate the capabilities of the Python library to run an end-to-end verifiable election or post-election audit.</p> <p> Source |   Package |   Documentation</p>  <p>Community-sourced Java port</p> <p>Check out our community contributions for a Java port.</p>","text":""},{"location":"develop/Repositories/#electionguard-c","title":"ElectionGuard C++   <p>The ElectionGuard C++ library performs ballot encryption. It is designed for devices that handle the user experience of voting. These devices follow the economics and performance of embedded systems: special-purpose devices designed for low cost. We assume Intel Atom class processor-level performance and Raspberry Pi 3 types of operating systems. In addition to the C++ library itself, there is some focus on target different standalone packages. This leads to the usage of other languages like C and C#.</p> <p> Source</p>","text":""},{"location":"develop/Repositories/#electionguard-python-api","title":"ElectionGuard Python API   <p>This API uses the <code>electionguard-python</code> package in a Python API utilizing FastAPI. This exposes the full featured Python ElectionGuard and allows users to create docker containers of the API. </p> <p> Source</p>","text":""},{"location":"develop/Repositories/#electionguard-ui","title":"ElectionGuard UI   <p>This UI application features several TypeScript packages as a monorepo, a version-controlled code repository that holds many projects, to reduce repeated tooling. It contains two web applications. One is an application to administer an election. The other is an application to display the election results. There are two helper packages, one functions as an api client and the other is a component library. </p> <p> Source</p>","text":""},{"location":"develop/Sample_Data/","title":"Sample Data","text":"<p>To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers. </p>"},{"location":"develop/Sample_Data/#four-sample-elections","title":"Four Sample Elections","text":"<p>We have provided sample data for four different elections:</p> <ul> <li> <p>Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referendum with a single ballot style in a single geopolitical unit.</p> </li> <li> <p>Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included.</p> </li> <li> <p>Full - This is a more realistic example for a primary election for a municipality. This ballot contains several geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples.</p> </li> <li> <p>Hamilton General - This is a complete example for a general election for a fictional municipality. This example contains many geopolitical units with multiple ballot styles and demonstrates how political districts overlap. This sample has multi-language support and multiple submitted ballot samples. The Hamilton General example also includes the election private data that includes guardian private keys. More information about the Hamilton General Example can be found in the Election Manifest Documentation.</p> </li> </ul> <p></p>"},{"location":"develop/Sample_Data/#data","title":"Data","text":""},{"location":"develop/Sample_Data/#election-manifests","title":"Election Manifests","text":"<p>The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election.</p> <p>Manifest Examples: [minimal][minimal-election-manifest] | [small][small-election-manifest] | [full][full-election-manifest] | hamilton</p>"},{"location":"develop/Sample_Data/#submitted-ballots","title":"Submitted Ballots","text":"<p>Submitted Ballots are encrypted ballots that have been cast or spoiled. Cast ballots will be tallied and spoiled ballots are decrypted.</p> <p>Submitted Ballot Examples: [minimal][minimal-election-ballot] | [small][small-election-ballot] | [full][full-election-ballot] | hamilton</p>"},{"location":"develop/Sample_Data/#election-record","title":"Election Record","text":"<p>The Election Record are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the record. </p> <p>Artifacts Examples: [minimal][minimal-election-record] | [small][small-election-record] | [full][full-election-record] | hamilton</p>"},{"location":"develop/Versioning/","title":"Versioning","text":"<p>Versioning for ElectionGuard as the Software Development Kit (SDK) may seem complex, particularly between the Specification, the code repositories, and the serialized files in the sample data. To attempt to reduce the complexity, the versioning for ElectionGuard will be as the whole SDK including the serialization, instead of individual components. This is to help the users of ElectionGuard identify the pieces and parts that function together. As an example, a verifier will need to support the same version(s) of ElectionGuard as the election system it is verifying.</p>"},{"location":"develop/Versioning/#how-it-works","title":"How It Works","text":"<ul> <li> <p>SDK version will line up with a specification post 1.0. This is to allow contributors to develop following the ElectionGuard Specification of the SDK and utilize the badge system to indicate what their code supports.</p> </li> <li> <p>Major versions will indicate this top level version consistently across the repositories starting in 1.0. The goal is to keep the Election Record and other serialized files consistent outside of major versions changes.</p> </li> <li> <p>Minor and smaller versions can differ to allow freedom within the code repositories. For example, the latest version python core could be v2.1.1 while the c++ core is at v2.48.0.</p> </li> </ul>"},{"location":"develop/Versioning/#current","title":"Current","text":""},{"location":"develop/Versioning/#electionguard-10","title":"ElectionGuard 1.0","text":"Part Link Release Specification PDF 1.1 Sample Data Unreleased 1.0 Python Core Unreleased 1.4 C++ Core Unreleased 1.0 Python API Unreleased 1.1 React UI Unreleased 1.0"},{"location":"develop/Versioning/#future","title":"Future","text":""},{"location":"develop/Versioning/#electionguard-20","title":"ElectionGuard 2.0","text":"Part Link Release Specification Unreleased 2.0 Sample Data Unreleased 2.0 Python Core Unreleased 2.0 C++ Core Unreleased 2.0 Python API Unreleased 2.0 React UI Unreleased 2.0"},{"location":"develop/Versioning/#previous","title":"Previous","text":""},{"location":"develop/Versioning/#electionguard-095","title":"ElectionGuard 0.95","text":"Part Link Release Specification PDF 0.95 Sample Data Source 0.95 Python Core Source 1.2.2 C++ Core Source 0.1.6"},{"location":"develop/Versioning/#electionguard-085","title":"ElectionGuard 0.85","text":"Part Link Release Specification PDF 0.85 C Core Deprecated 1.0 C# Core Deprecated 1.0"},{"location":"elections/College_Park_Maryland_2023/","title":"College Park, Maryland 2023","text":""},{"location":"elections/College_Park_Maryland_2023/#electionguard-in-the-november-2023-college-park-general-election","title":"ElectionGuard in the November 2023 College Park General Election","text":"<p>This November will see College Park use the Hart VerityScan scanner with ElectionGuard in a similar configuration to what was used in the Preston Idaho election in 2022. This year, voters will fill out ballots either by hand or using Hart's Verity TouchWriter. The official tally will be conducted with the Hart system, which will include mail-in ballots scanned with the VerityScan scanner but, because the voters were not present to collect the confirmation code receipt, will not be able to verify that their ballots were included.</p> <p>Vote by mail is a feature of the ElectionGuard 2.0 Specification</p>"},{"location":"elections/College_Park_Maryland_2023/#new-capabilities","title":"New Capabilities","text":"<p>While the core Hart system and voting process will be identical to the system used in Preston, Idaho the ElectionGuard software will be almost (see below) a full implementation of the 2.0 specification. It incorporates most of the new encryption structures, including a new implementation of guardian architecture and elimination of placeholder votes.  A fully new version of the admin and guardian software used to run the key and tally ceremonies has also been developed.</p> <p>The biggest new capability is a full implementation of thresholding. Thresholding enables a quorum of guardians to participate in a tally ceremony rather than requiring all guardians to be present. (College Park will be using 5 guardians with a quorum of 3 to be present to run the tally ceremony.) Each guardian and the ElectionGuard administrator will be assigned their own Surface Go tablet to run the ceremonies and will use Windows Hello to authenticate on their assigned device.</p>"},{"location":"elections/College_Park_Maryland_2023/#ballot-confirmation","title":"Ballot Confirmation","text":"<p>Voters will be able to confirm that their votes were counted using Enhanced Voting's Confirmation Code lookup website, as happened in Preston. The ElectionGuard election record will be hosted there as well, enabling independent verifiers to access and confirm the election results.</p>"},{"location":"elections/College_Park_Maryland_2023/#independent-verification-of-the-college-park-election","title":"Independent Verification of the College Park Election","text":"<p>In order to meet the deadline to support College Park and its integration with Hart, the ElectionGuard software was frozen prior to completion of the full 2.0 implementation. As a result, the software used in College Park will be an implementation hybrid of the 2.0, 1.53, and 1.1 specs (officially 1.91.18).</p> <p>ElectionGuard 1.91.18 should not be used outside of the College Park election</p> <p>The ElectionGuard software used in College Park is not general release software. It is published here for the purposes of creating a public record of the College Park election. While this release creates an independently verifiable set of artifacts, it should not be used in other elections.</p> <p>As a result,there are known aspects of the full 2.0 specification that will not be delivered for November. Specifically, Verification 6 (Adherence to vote limits) and 7.A and 7.B of Verification 7 (Validation of Confirmation codes) were not implemented correctly so cannot be verified. Full support for handling encrypted data was not enabled so Verification 11 (Correctness of decryptions of contest data) and Verification 14 (Correctness of contest data decryptions for challenged ballots) could not be implemented by an independent verifier, either.</p> <p>There are fixes already in place that will be published after College Park, but to meet deployment and QA timelines were not released as part of 1.91.18. While it is not best practice by any means to intentionally omit support of components of independent verifier validations, some validations are more important than others, and the implementation risk of missing our deadlines for College Park outweighed the incremental benefit of delivery of the missing elements.</p> <p>In addition, there are features that are outlined in the 2.0 spec that are not used in the College Park election, and independent verifier support is thus not necessary nor expected for 1.91.18:</p> <ul> <li>Ballot chaining</li> <li>Pre-encrypted ballots</li> <li>Instant verification (BallotCheck)</li> <li>Any voting method other than precinct scan</li> <li>Encrypted contest data (write-ins, overvotes/undervotes, extended data)</li> </ul> <p>Finally, when the verifier was run initially immediately after the tally ceremony on November 5, a data error was discovered around the extended base hash, causing the MITRE 1.I verification (1.H in the 2.0 Specification) to fail. The error was due to an already-addressed issue regarding equation formulation, yet the desired approach was implemented differently in the verifier versus the production code. Since the core ElectionGuard code could not be updated (due to the code freeze cited above), the verifier was modified to interpret the extended base hash correctly and the election was fully verified according to the precepts agreed to above.</p> <p>The MITRE Requirements document outlines in detail the encryption and election record capabilities adopted by their verifier for College Park.</p> <p>Run the verifier yourself!</p> <p>If you want to run the MITRE verifier yourself, follow the instructions here. The election record for College Park is available at the confirmation code lookup website.</p>"},{"location":"elections/College_Park_Maryland_2023/#survey-and-feedback-from-voters","title":"Survey and Feedback from Voters","text":"<p>In-person voters will be asked to participate in an exit survey, and all College Park residents are welcome to participate in an election survey collecting general election feedback in addition to perspectives on ElectionGuard. Upon survey completion, the Center for Civic Design will publish a report on voter sentiment.</p>"},{"location":"elections/Fulton_Wisconsin_2020/","title":"Fulton, Wisconsin 2020","text":""},{"location":"elections/Fulton_Wisconsin_2020/#electionguard-in-the-february-2020-fulton-wisconsin-special-election","title":"ElectionGuard in the February 2020 Fulton, Wisconsin Special Election","text":"<p>In February, 2020, the town of Fulton, Wisconsin, hosted a special election using ElectionGuard in a voting system built in partnership with VotingWorks. This was the first time ElectionGuard was used in a live election, and while the official tally was determined by a hand count, both the VotingWorks system and ElectionGuard recorded the same results that was validated by the hand count.</p> <p>The voting system used programmable smart cards to record and print their ballot as well as create the ElectionGuard encrypted ballot. Voters filled out their ballots using a VotingWorks ballot marking device. The ballot was stored in both VotingWorks and ElectionGuard encrypted versions, and printed for voters to review and deposit into a ballot box. The paper ballots were tabulated using a VotingWorks scanner.</p> <p>Three election guardians oversaw the ElectionGuard tally process. No independent verifier was written.</p>"},{"location":"elections/Fulton_Wisconsin_2020/#resources","title":"Resources","text":""},{"location":"elections/Fulton_Wisconsin_2020/#microsoft-hopes-its-technology-will-help-americans-trust-voting-again-cnn-febrary-22-2020","title":"\"Microsoft hopes its technology will help Americans trust voting again\" CNN, Febrary 22, 2020","text":""},{"location":"elections/Fulton_Wisconsin_2020/#microsofts-voting-software-is-getting-its-first-test-in-a-small-wisconsin-town-cnbc-february-18-2020","title":"\"Microsoft\u2019s voting software is getting its first test in a small Wisconsin town\" CNBC, February 18, 2020","text":""},{"location":"elections/Preston_Idaho_2022/","title":"Preston, Idaho 2022","text":""},{"location":"elections/Preston_Idaho_2022/#electionguard-in-the-november-2022-general-election","title":"ElectionGuard in the November 2022 General Election","text":"<p>New Report to the Election Assistance Commission (EAC)</p> <p>Check out our report to the EAC on the Idaho election.</p> <p>In the Preston, Idaho District #4 General Election, Idaho voters experienced ElectionGuard for the first time. Specifically, they were able to use a confirmation code to see for themselves that their ballot was counted. In total, 40% of voters opted to use the ElectionGuard / Hart option (as opposed to the traditional option of dropping hand-marked paper ballots into a ballot box).</p> <p></p> <p>Other vendors contributed services and capabilities to showcase how independent verification of elections work: Hart InterCivic integrated ElectionGuard into its Verity precinct scanners; MITRE wrote an independent verifier; and Enhanced Voting provided the confirmation code lookup service.</p>"},{"location":"elections/Preston_Idaho_2022/#confirmation-code-lookup","title":"Confirmation Code Lookup","text":"<p>Voters were able to confirm that their vote was counted by scanning their confirmation code (or entering the code manually). The election record itself is also available on Enhanced Voting's Confirmation Code Lookup website.</p>"},{"location":"elections/Preston_Idaho_2022/#independent-verification","title":"Independent Verification","text":"<p>MITRE wrote an independent verifier for this election to ensure that ElectionGuard was working correctly. You can go to the Verifier site to see a report of mathematical tests of the ElectionGuard specification. </p>"},{"location":"elections/Preston_Idaho_2022/#pilot-qas","title":"Pilot Q&amp;A's","text":"How was the pilot conducted? <p>The ElectionGuard pilot ran alongside the normal election processes.</p> <ul> <li>Voters marked their ballots as usual.</li> <li>They used a scanner in the polling place to cast their ballots, instead of putting them in a box to be counted at the election office.  </li> <li>The scanner showed them a summary of their vote, and then allowed them to cast the ballot, make changes before casting, or opt to run a BallotCheck.  </li> </ul> Who was part of the pilot? <p>The pilot took place in Preston, Idaho District #4 on Election Day. Participation was optional - voters in the district could opt-out of the pilot. Poll workers received extra training so they could support voters using ElectionGuard. Two Election Guardians created the locks and keys to set up ElectionGuard.  </p> How were the votes counted? <p>The jurisdiction hand-counted the ElectionGuard ballots to record the official tally, but used the results from the ElectionGuard tally and Hart scanner reports as confirmation. The ElectionGuard pilot data was compared to the official results as part of testing the new technology.</p> What made the pilot a success? <p>The pilot was as chance to test the technology in a real environment, demonstrating that: </p> <ul> <li>All the parts of ElectionGuard could work together in a live election  </li> <li>An independently created Election Verifier could check the results of the tally </li> <li>The Hart scanner with ElectionGuard did not add to voting times or create additional lines or backups</li> </ul> <p>The pilot enabled us to learn about the impact on voters, especially whether they:</p> <ul> <li>Understood the value and benefits of ElectionGuard </li> <li>Took the opportunity to confirm that their ballot counted </li> <li>Increased their confidence in the accuracy and security of elections.\u00a0</li> </ul>"},{"location":"events/eg_usability_aug_2022/","title":"ElectionGuard Hart Verity Scanner and Usability Convening August 3-5, 2022","text":""},{"location":"events/eg_usability_aug_2022/#overview","title":"Overview","text":"<p>This convening is a hybrid event that will be held both virtually on Microsoft Teams and in-person at the Microsoft campus in Redmond, Washington. All times Pacific Daylight Time (PDT).</p>"},{"location":"events/eg_usability_aug_2022/#agenda","title":"Agenda","text":""},{"location":"events/eg_usability_aug_2022/#wednesday-august-3","title":"Wednesday, August 3","text":""},{"location":"events/eg_usability_aug_2022/#electionguard-hart-verity-precinct-scan-implementation-and-ecosystem","title":"ElectionGuard Hart Verity Precinct Scan Implementation and Ecosystem","text":"What is ElectionGuard and How Does It Work?  [RC Carter, Microsoft] <p>  Video |   Presentation  </p> An Overview of the ElectionGuard Ecosystem [Josh Benaloh, Microsoft] <p>  Video |   Presentation</p> ElectionGuard Integrated Election Setup (demonstration) [Lee Richardson and  Steve Maier, InfernoRed; RC Carter, Microsoft] <p>  Video</p> Implementing End-to-End Verifiability in the Verity Voting System: Lessons in ElectionGuard Integration and the Voting Experience (includes demonstration) [Jim Canter, Eugene Konovalenko, and Drew Tinney, Hart] <p>  Video |   Presentation</p> Generating the Election Record (demonstration) [Lee Richardson and  Steve Maier, InfernoRed; RC Carter, Microsoft] <p>  Video</p> Confirmation Code Lookup Site (demonstration) [Aaron Wilson, Enhanced Voting] <p>  Video</p> <p>Practical ElectionGuard Verifier Implementation (includes demonstration)[Moses Liskov and Dr. John Ramsdell, MITRE]</p> <p>  Video |   Presentation</p>"},{"location":"events/eg_usability_aug_2022/#thursday-august-4","title":"Thursday, August 4","text":""},{"location":"events/eg_usability_aug_2022/#usability-and-accessibility-in-us-elections","title":"Usability and Accessibility in US Elections","text":"Ballot Marking Device Verification: Can vs. Do [Mike Byrne, Rice University] <p>  Video |   Presentation | Related publication: \"Can Voters Detect Errors on Their Printed Ballots? Absolutely\" Philip Kortum, Michael D. Byrne, Chidera O. Azubike, Laura E. Roty |</p> Opportunities for Accessibility Innovation with VVSG 2.0 [Whitney Quesenberry, Center for Civic Design] <p>  Video |   Presentation</p> EAC Perspectives on Accessibility, End-to-End Verifiability, and VVSG 2.0 [Thomas Hicks, Election Assistance Commission] <p>  Video |   Presentation</p> Panel Discussion: Usability Considerations that Can Improve Security and Independence [Clark Rachfal, American Council of the Blind; Michelle Bishop, MSW, National Disability Rights Network; Diana Mairose, Self Advocates Becoming Empowered; moderated by Rylin Rodgers, Microsoft] <p>  Video | View the SABE GoVoter Project Report</p>"},{"location":"events/eg_usability_aug_2022/#voting-method-accessibility-and-security-innovations","title":"Voting Method, Accessibility, and Security Innovations","text":"Secure Accessible Voting with ElectionGuard [Aaron Wilson, Enhanced Voting] <p>  Video |   Presentation</p> Implementing End-to-end Verifiability for Vote by Mail [Braden Crimmins, University of Michigan] <p>  Video |   Presentation</p> What's Next? ElectionGuard 2.0 [Michael Naehrig, Microsoft] <p>  Video |   Presentation</p>"},{"location":"events/eg_usability_aug_2022/#friday-august-5-nerd-day","title":"Friday, August 5: Nerd Day","text":"10:00-2:00 Technical discussions focusing on ElectionGuard 2.0 innovations, implementation options, roadmap, and opensource community <p>View the current agenda for Nerd Day</p>"},{"location":"overview/Glossary/","title":"ElectionGuard Glossary","text":""},{"location":"overview/Glossary/#overview","title":"Overview","text":"<p>This glossary is intended to provide terms that are applicable to a variety of audiences:</p> <ol> <li>Election administrators - Terms that map to their conception of the voting process and user experience</li> <li>Developers - Provides entities, constructs, and a detailed grammar that allows them to solve problems quickly</li> <li>Cryptographers &amp; election technology contributors - Consistency of usage between the specification and programming code, and sufficiently clear descriptions of the techniques and terms necessary for proper treatment and interpretation of the election record and all processes</li> <li>General public - Clear articulation of the meaning and rationale for the different facets of end-to-end verifiability</li> </ol> <p>Info</p> <p>ElectionGuard seeks to keep most terms and meanings consistent the NIST Election Results Common Data Format Specification and the Civics Common Standard Data Specification. These can be helpful additions to this glossary.</p>"},{"location":"overview/Glossary/#terms","title":"Terms","text":"<p>Utilize the search bar to ease searching for a particular terms. There are \"other terms\" sections to reduce the difficulty to search possible outdated or deprecated terms.</p>"},{"location":"overview/Glossary/#approval-voting","title":"approval voting","text":"<p>Approval voting is a single-winner electoral system where each voter may choose or approve any number of candidates, and the winner is the single candidate approved by the largest number of voters. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. </p>"},{"location":"overview/Glossary/#auxiliary-key-pair","title":"auxiliary key pair","text":"<p>A key pair owned by a specific guardian for encryption to securely send information to other guardians.</p>"},{"location":"overview/Glossary/#other-terms-auxiliary-keys","title":"Other terms: auxiliary keys","text":""},{"location":"overview/Glossary/#ballot-box","title":"ballot box","text":"<p>A term used to represent collection of submitted ballots in programming code mimicking the physical item.</p>"},{"location":"overview/Glossary/#ballot-chain","title":"ballot chain","text":"<p>If the ballots are encrypted in a particular order by an encryption device, this creates a ballot chain. This can be useful for verification purposes because an inserted or removed ballot can be easily detected as a break in the chain.</p>"},{"location":"overview/Glossary/#ballot-code","title":"ballot code","text":"<p>A unique hash value generated by an encryption device to anonymously identify a ballot and allow the voter to confirm the ballot has been submitted. code is not to be confused with programming code, but is rather a code to confirm the ballot.</p>"},{"location":"overview/Glossary/#other-terms-code-confirmation-code-ballot-confirmation-code-verification-code-deprecated","title":"Other terms: code, confirmation code, ballot confirmation code, verification code (deprecated)","text":""},{"location":"overview/Glossary/#ballot-decryption","title":"ballot decryption","text":"<p>Decrypting a secure encrypted ciphertext ballot to a readable plaintext ballot.</p>     graph LR     a1(ciphertext ballot) --&gt;|decrypt| a2(plaintext ballot)"},{"location":"overview/Glossary/#ballot-encryption","title":"ballot encryption","text":"<p>Encrypting a readable plaintext ballot to a secure encrypted ciphertext ballot.</p>     graph LR     a1(plaintext ballot) --&gt;|encrypt| a2(cipertext ballot)"},{"location":"overview/Glossary/#ballot-lifecycle","title":"ballot lifecycle","text":"<p>The lifecycle the ballot goes through. For ElectionGuard, the ballot goes from a plaintext ballot to a ciphertext ballot to a submitted ballot and then it is either (1) cast, added to tally or (2) spoiled and decrypted during tally ceremony. </p>"},{"location":"overview/Glossary/#candidate","title":"candidate","text":"<p>A candidate is a choice or option on a contest. This can represent a named a named candidate but also word choices like yes or no. </p>"},{"location":"overview/Glossary/#other-terms-choice-option","title":"Other terms: choice, option","text":""},{"location":"overview/Glossary/#cast-ballot","title":"cast ballot","text":"<p>A ballot which a voter has submitted as cast to be included in the official election tally.</p>"},{"location":"overview/Glossary/#other-terms-cast-casting","title":"Other terms: cast, casting","text":""},{"location":"overview/Glossary/#ciphertext-ballot","title":"ciphertext ballot","text":"<p>An encrypted representation of a voter's filled-in ballot.</p>"},{"location":"overview/Glossary/#other-terms-encrypted-ballot","title":"Other terms: encrypted ballot","text":""},{"location":"overview/Glossary/#ciphertext-election-context","title":"ciphertext election context","text":"<p>The cryptographic context of an election constructed following the key ceremony. This is a programming concept to coordinate the cryptographic information about the election such as the number of guardians and quorum, and joint key.</p>"},{"location":"overview/Glossary/#other-terms-election-context-context","title":"Other terms: election context, context","text":""},{"location":"overview/Glossary/#ciphertext-tally","title":"ciphertext tally","text":"<p>A ciphertext tally is the homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. It is an aggregate of all the encrypted cast ballots in the election. The ciphertext tally is the tally while it is is still in the encrypted state.</p>"},{"location":"overview/Glossary/#other-terms-aggregate-ciphertext-ballot","title":"Other terms: aggregate ciphertext ballot","text":""},{"location":"overview/Glossary/#compact-ballot","title":"compact ballot","text":"<p>A compact ballot is an ElectionGuard term for an encrypted or plaintext ballot that contains only the basic information for a ballot to allow for faster performance and smaller data size. The compact ballot saves space by removing information that can be reconstituted like contest info from the manifest or mathematical proofs. </p>"},{"location":"overview/Glossary/#compensated-decryption-share","title":"compensated decryption share","text":"<p>A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the tally can be successfully decrypted.</p>"},{"location":"overview/Glossary/#contest","title":"contest","text":"<p>A contest in an manifest consists of a set of candidates or options together with a selection limit. Contests can be customized to suit the voting experience with options like approval voting, ranked-choice voting and write-ins. Contests can have special rules around selection limits to handle undervotes, overvotes, and null votes.</p>"},{"location":"overview/Glossary/#decryption-share","title":"decryption share","text":"<p>A guardian's partial share of a ballot decryption or tally decryption.</p>"},{"location":"overview/Glossary/#election","title":"election","text":"<p>An election in ElectionGuard is an election as described by a manifest. An election will have one encryption key to encrypt ballots and after tally, will result in an election record.</p>"},{"location":"overview/Glossary/#election-key-pair","title":"election key pair","text":"<p>A key pair owned by a specific guardian for joint encryption in combination with the other guardians to secure the election.</p>"},{"location":"overview/Glossary/#other-terms-election-keys-guardian-key-pair-guardian-keys","title":"Other terms: election keys, guardian key pair, guardian keys","text":""},{"location":"overview/Glossary/#election-partial-key-backup","title":"election partial key backup","text":"<p>A point on a secret election polynomial and commitments to verify this point for a designated guardian.</p>"},{"location":"overview/Glossary/#other-terms-backup","title":"Other terms: backup","text":""},{"location":"overview/Glossary/#election-partial-key-verification","title":"election partial key verification","text":"<p>A guardian's verification that a received election partial key backup is valid to ensure decryption can occur with missing guardians in the tally ceremony.</p>"},{"location":"overview/Glossary/#other-terms-backup-verification","title":"Other terms: backup verification","text":""},{"location":"overview/Glossary/#election-polynomial","title":"election polynomial","text":"<p>The election polynomial is the mathematical expression that each guardian uses for encryption. Each guardian has a polynomial where the first coefficient is used to generate their election key pair. A different point associated with the polynomial is shared with each of the other guardians in the key ceremony so that the guardians can come together and decrypt in the tally ceremony.</p>"},{"location":"overview/Glossary/#election-record","title":"election record","text":"<p>A verifiable record of the public artifacts or files of the election. This includes items like the manifest and the encrypted ballots so an individual or third party can verify the election end-to-end.</p>"},{"location":"overview/Glossary/#other-terms-record-election-artifacts-deprecated","title":"Other terms: record, election artifacts (deprecated)","text":""},{"location":"overview/Glossary/#electionguard-core","title":"ElectionGuard Core","text":"<p>A programming code base that implements fundamental features of the ElectionGuard Specification (such as ballot encryption) to act as a core or central integration.</p>"},{"location":"overview/Glossary/#electionguard-specification","title":"ElectionGuard Specification","text":"<p>The specification indicating how ElectionGuard creates end-to-end verifiable elections. See Specification.</p>"},{"location":"overview/Glossary/#electionguard-sdk","title":"ElectionGuard SDK","text":"<p>The entire set of repositories associated with ElectionGuard. See Repositories.</p>"},{"location":"overview/Glossary/#encryption-device","title":"encryption device","text":"<p>A device loaded with the election context that performs ballot encryption.</p>"},{"location":"overview/Glossary/#encryption-seed","title":"encryption seed","text":"<p>The encryption seed is the starting number or point for the encryption. The seed is usually a hash either the starting hash from the encryption device or with a ballot chain the hash from the previous ballot. </p>"},{"location":"overview/Glossary/#other-terms-seed-hash","title":"Other terms: seed hash","text":""},{"location":"overview/Glossary/#end-to-end-verifiable-election","title":"end-to-end-verifiable election","text":"<p>End-to-end verifiable election techniques enable individual voters to check crucial ingredients of election results \u2013 without requiring voters to trust election software, hardware, election officials, procedures, or even observers. Voters may check these ingredients themselves, place their trust in others of their choice (e.g. their preferred candidates, news media, and/or interest groups), or accept the outcome produced with the usual administrative safeguards.<sup>1</sup></p> <p>An end-to-end verifiable election  must include two principle components:</p> <ul> <li>Cast as intended - Voters can verify that their own selections have been correctly recorded.</li> <li>Counted as cast - Anyone can verify that the recorded votes have been correctly tallied.</li> </ul>"},{"location":"overview/Glossary/#guardian","title":"guardian","text":"<p>One of a number of independent, trustworthy individuals who serve guardians in the election. All guardians must participate in a key ceremony to create a key to encrypt the election and may participate in the accompanying tally ceremony(s) to decrypt the tally(s). A guardian is available if they are available for the tally ceremony. A guardian is missing if they cannot attend the tally ceremony.</p>"},{"location":"overview/Glossary/#other-terms-election-guardian-missing-guardian-available-guardian","title":"Other terms: election guardian, missing guardian, available guardian","text":""},{"location":"overview/Glossary/#hash","title":"hash","text":"<p>Hashing is a common practice in computing as a mechanism to map data of an arbitrary size into a fixed-size equivalent. ElectionGuard uses hashing in its cryptographic context, This is done for a variety of reasons, including preventing discovery of election ballot contents, but also to verify certain information. For example, a hash of the manifest is added to the ballot which can verify the ballot is using the correct manifest.</p>"},{"location":"overview/Glossary/#joint-key","title":"joint key","text":"<p>A public encryption key which is the combination the public key of the election key pair of each of the guardians. This key is created as the last step in the key ceremony.</p> <p>Creating a joint public key as part of the key ceremony     graph LR     a2 &amp; b2 &amp; c2 --&gt; jk1[key ceremony] --&gt; jk2(joint public key)     subgraph eg1[guardian 1]     a1(private key) -.- a2(public key)     end     subgraph eg2[guardian 2]     b1(private key) -.- b2(public key)     end     subgraph eg3[guardian n]     c1(private key)  -.- c2(public key)     end </p>"},{"location":"overview/Glossary/#other-terms-joint-public-key-encryption-key-ballot-encryption-key-elgamal-key","title":"Other terms: joint public key, encryption key, ballot encryption key, elgamal key","text":""},{"location":"overview/Glossary/#key-ceremony","title":"key ceremony","text":"<p>The process conducted at the beginning of the election to create the joint key for ballot encryption during the election. In ElectionGuard, each guardian creates an election key pair and shares a recovery method for their decryption with the other election guardians as part of the key ceremony in case that particular guardian cannot attend the tally ceremony.</p>"},{"location":"overview/Glossary/#key-pair","title":"key pair","text":"<p>A key pair consists of a linked private key and public key. Key pairs are used in public key cryptography, in which public keys are distributed to others to encrypt messages that only the private key can decrypt.</p>     graph LR     subgraph kp[key pair]     a1(private key) -.- a2(public key)     end"},{"location":"overview/Glossary/#manifest","title":"manifest","text":"<p>The manifest is the information that uniquely specifies and describes the structure and type of the election, including geopolitical units, contests, candidates, ballot styles, etc. In ElectionGuard, it is a file that is created before running an election. The internal manifest is a wrapper around the manifest used in programming code to simplify and avoid processing the same information twice. Unlike the manifest, the internal manifest is not meant for serialization.</p>"},{"location":"overview/Glossary/#other-terms-election-manifest-election-description-deprecated-internal-election-description-deprecated","title":"Other terms: election manifest, election description (deprecated), internal election description (deprecated)","text":""},{"location":"overview/Glossary/#mediator","title":"mediator","text":"<p>A mediator is used to mediate communication (if needed) of information such as keys between the guardians. This can be a person but in ElectionGuard this often refers to the server mediating / coordinating between the guardian machines that maintains all the public information between the key and tally ceremonies.</p>"},{"location":"overview/Glossary/#other-terms-key-ceremony-mediator-tally-mediator","title":"Other terms: key ceremony mediator, tally mediator","text":""},{"location":"overview/Glossary/#nonce","title":"nonce","text":"<p>An arbitrary number used for cryptographic applications particularly encryption.</p>"},{"location":"overview/Glossary/#non-interactive-zero-knowledge-proof-nizk","title":"non-interactive-zero-knowledge proof (NIZK)","text":"<p>A non-interactive-zero-knowledge proof (NIZK) is a zero-knowledge proof that can be performed without interaction or intervention by the prover.</p>"},{"location":"overview/Glossary/#null-vote","title":"null vote","text":"<p>An null vote occurs when no candidate is selected for a contest. Example: A contest where 2 candidate must be selected and 0 are chosen.</p>"},{"location":"overview/Glossary/#overvote","title":"overvote","text":"<p>An overvote occurs when too many candidates are selected for a contest. Example: A contest where 2 candidate must be selected and 3 are chosen.</p>"},{"location":"overview/Glossary/#placeholder","title":"placeholder","text":"<p>A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes or null votes, the internal representation of a contest in programming code is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option.</p> <p>With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest.</p>"},{"location":"overview/Glossary/#plaintext-ballot","title":"plaintext ballot","text":"<p>The plaintext representation of a voter's selections.</p>"},{"location":"overview/Glossary/#other-terms-ballot","title":"Other terms: ballot","text":""},{"location":"overview/Glossary/#plaintext-tally","title":"plaintext tally","text":"<p>A plaintext tally is the summation of votes for each candidate for each contest in the election. The plaintext tally, or just tally, is the decrypted ciphertext tally or decrypted aggregate ballot which contains the election results.</p>"},{"location":"overview/Glossary/#other-terms-aggregate-ballot-tally-election-results","title":"Other terms: aggregate ballot, tally, election results","text":""},{"location":"overview/Glossary/#post-election-audit","title":"post-election audit","text":"<p>A post-election audit verifies that the voting equipment used to count ballots during an election properly counts a sample of voted ballots after an election</p>"},{"location":"overview/Glossary/#quorum","title":"quorum","text":"<p>The minimum count of guardians that must be present in order to successfully decrypt the tally.</p>"},{"location":"overview/Glossary/#other-terms-threshold","title":"Other terms: threshold","text":""},{"location":"overview/Glossary/#ranked-choice-voting-rcv","title":"ranked-choice voting (RCV)","text":"<p>A ranked-choice voting is an electoral system in which voters rank candidates by preference on their ballots. ElectionGuard does not currently support this.</p>"},{"location":"overview/Glossary/#risk-limiting-audit-rla","title":"risk-limiting audit (RLA)","text":"<p>A risk-limiting audit is a post-election audit that provides strong statistical evidence that the election outcome is correct. RLA has a high probability of correcting a wrong outcome.</p>"},{"location":"overview/Glossary/#selection","title":"selection","text":"<p>A selection or vote is the selected candidate(s) or option(s) in a contest on a voter's ballot.</p>"},{"location":"overview/Glossary/#other-terms-ballot-selection-candidate-selection-vote","title":"Other terms: ballot selection, candidate selection, vote","text":""},{"location":"overview/Glossary/#selection-limit","title":"selection limit","text":"<p>The limit of selections that indicates the number of selections that are allowed to be made in that contest. Most contests have a selection limit of one, but a larger selection limit (e.g., select up to three) is not uncommon in certain elections. </p>"},{"location":"overview/Glossary/#sequence-order","title":"sequence order","text":"<p>The sequence order is a field used to ensure items such as contests, selections, or guardians are in order for functions that require specific ordering. \"In sequence order\" means ordered by increasing sequence order number.</p>"},{"location":"overview/Glossary/#spoiled-ballot","title":"spoiled ballot","text":"<p>Spoiling allows a voter to turn in their ballot without their ballot being included in the election tally. A spoiled ballot is a ballot the voter has submitted as spoiled. The voter must submit a replacement ballot as their official cast ballot.</p> <p>In ElectionGuard, ballot spoiling is used as a means for voters to challenge the voting machine and force it to reveal the contents of spoiled ballots for public scrutiny. In this way, a spoiled ballot challenges the system and the term challenge ballot is used. The ballot is spoiled after encryption where the machine cannot modify the ballot. Since the ballot will not be used in the official tally, the content of the ballot can be revealed at the same time as the tally allowing a voter to verify the encryption and decryption process.</p>"},{"location":"overview/Glossary/#other-terms-spoil-spoiling-challenge-ballot","title":"Other terms: spoil, spoiling, challenge ballot","text":""},{"location":"overview/Glossary/#submitted-ballot","title":"submitted ballot","text":"<p>A ballot that is submitted for inclusion in the election and is either: cast or spoiled.</p>     graph LR     a1(encrypted ballot) --&gt;|cast| a2(submitted ballot)     a1 --&gt; |spoiled| a2"},{"location":"overview/Glossary/#other-terms-accepted-ballot-deprecated","title":"Other terms: accepted ballot (deprecated)","text":""},{"location":"overview/Glossary/#tally-ceremony","title":"tally ceremony","text":"<p>The process of decrypting the encrypted tally to the decrypted tally. The guardians from the key ceremony who are available attend this ceremony. There must be at least enough guardians to meet the quorum. Each guardian will decrypt their decryption shares and their share for each missing guardian. These shares will then be combined to create the decrypted spoiled ballots and decrypted tally.</p>"},{"location":"overview/Glossary/#tally-decryption","title":"tally decryption","text":"<p>Decrypting an encrypted ciphertext tally to a readable plaintext tally to view results. This is essentially the same concept as ballot decryption.</p>     graph LR     a1(ciphertext tally) --&gt;|decrypt| a2(plaintext tally)"},{"location":"overview/Glossary/#star-voting-method","title":"STAR Voting Method","text":"<p>STAR (an acronym for Score Then Automatic Runoff) voting is an electoral system in which voters rate the candidates for a given office on a scale of zero to five, with zero indicating no support and five indicating maximum support. </p> <p>The scores for all candidates are then tabulated and the top two finishers advance to an automatic runoff, at which time a voter's full vote is assigned to whichever of the two finishers he or she scored highest. The candidate whom a greater number of voters gave a higher score in the runoff is declared the winner. </p> <p>STAR Voting is Presinct Summable and allows homomorphic encryption (simple addition).</p>"},{"location":"overview/Glossary/#undervote","title":"undervote","text":"<p>An undervote occurs when too little candidates are selected for a contest. Example: A contest where 2 candidate must be selected and 1 is chosen. Selecting no candidates at all will result in a null vote.</p>"},{"location":"overview/Glossary/#unknown-ballot","title":"unknown ballot","text":"<p>An unknown ballot is a submitted ballot which has not been determined to be cast or spoiled, or that may have been spoiled but is otherwise not published in the election results.</p>"},{"location":"overview/Glossary/#write-in","title":"write-in","text":"<p>A write-in is a candidate or option which does not appear on the manifest's contest. For ElectionGuard, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. </p>"},{"location":"overview/Glossary/#zero-knowledge-proof","title":"zero-knowledge proof","text":"<p>A zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that they know a value <code>x</code>, without conveying any information apart from the fact that they know the value <code>x</code>. The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information.<sup>2</sup></p> <ol> <li> <p>End-to-end verifiability \u21a9</p> </li> <li> <p>Zero-Knowledge Proof from Wikipedia \u21a9</p> </li> </ol>"},{"location":"overview/Roadmap/","title":"ElectionGuard Roadmap","text":""},{"location":"overview/Roadmap/#2023-roadmap","title":"2023 Roadmap","text":"<p>2023 targets a fully updated version of the core ElectionGuard specification as well as a new approach to the core software deliverables. Instead of a \"reference implementation\" approach in Python, we are pursuing a C++ core that can deliver production-level performance for encryption. Other programming languages will be supported via templates.</p> <p>The specification itself will accommodate a lot of efficiency improvements and some longstanding feature requests focused on supporting commercial implementations for vendors integrating ElectionGuard into their systems.</p> 2.0 Specification <ul> <li>improved encryption speed and more efficient storage</li> <li>reduced verifier complexity</li> <li>range proofs</li> <li>ability to support recounts and additional methods of voting such as vote by mail</li> </ul> Single, simplified fully C++-based SDK <ul> <li>eliminate problems of serialization and rationalization of challenges working across different languages</li> </ul> Upgraded Key and Tally Ceremony user experience <ul> <li>production-ready user experience</li> <li>clearer, stepper-based process</li> <li>implements thresholding</li> <li>improved visibility into manifest selection and review</li> </ul> Full Guardian Thresholding support <ul> <li>ability to specify maximum and quorum number of guardians</li> <li>ability for admins to initiate tally ceremony once quorum has been reached</li> <li>updated thresholding code that simplifies verifier</li> </ul>"},{"location":"overview/Roadmap/#2022-roadmap","title":"2022 Roadmap","text":"<p>2022 focused on a full 1.0 release of functionality across the Python and C++ repos. We needed to support a pilot election in Franklin County, Idaho in partnership with Hart InterCivic on their Verity Precinct Scanner. MITRE worked with us to release the first truly full-featured verifier that was used to verify the election results, and Enhanced Voting hosted the confirmation-code-lookup website.</p>"},{"location":"overview/Roadmap/#2021-roadmap","title":"2021 Roadmap","text":"<p>The 2021 roadmap takes lessons learned from the deployment of applications during 2020 and rationalizes them into a practice to establish with the community in 2021. The goal is to grow a community of participants and contributors within which Microsoft takes part and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits.</p> <p>A big step toward this new vision occurred with the release of the <code>electionguard-cpp</code> ballot-encryption repo. The <code>electionguard-python</code> repo implements the full suite of ElectionGuard SDK functionality and the base <code>electionguard</code> specification and documentation repo provides the foundation for future development. The goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. The goal is also to publish and generate more comprehensive and also more granular examples and use cases to enable easier and more focused contributions by the community.</p> 1.0 Specification <ul> <li>a final, fully-developed specification integrated directly into the SDK;</li> <li>updates to election manifest and election artifact descriptions and specifications</li> <li>a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute</li> <li>more prescriptive guidance on verifier construction</li> </ul> C++ ballot encryption library <ul> <li>repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners)</li> <li>standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!)</li> <li>enables ElectionGuard to eliminate GMP as a dependency </li> </ul> Release an ElectionGuard.Encryption nuget package built from <code>electionguard-cpp</code> as a ballot encrypter for low performance devices <ul> <li>Establish publishing pattern</li> <li>First target will be Windows 10 / UWP</li> </ul> A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos <ul> <li>Data serialization using Protobuf for input/output/data consistency across <code>electionguard-cpp</code> and <code>electionguard-python</code></li> <li>Restructuring ballot and device aggregation to better support audits and scalability in general</li> <li>Renaming and refactoring all repos for more descriptive and specific naming patterns</li> </ul> Compose community changes into <code>electionguard-python</code> release v1.1.16 Optimization changes for service implementations of <code>electionguard-python</code> release v1.4.0  Introduce service docker containers in <code>electionguard-api</code>"},{"location":"overview/Roadmap/#2020-in-review","title":"2020 In Review","text":"<p>2020 provided many lessons.</p> <p>During the first half of the year ElectionGuard was used successfully as a Pilot in Fulton, WI with the help of VotingWorks and InfernoRed. Subsequent to the pilot ElectionGuard released the Python repo as a new reference implementation.</p> <p>In the second half of the year, responding to COVID, led to the development of a remote voting app with InfernoRed, Markup, and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions. </p> <p>In a further collaborate with VotingWorks, Rice University professor Dan Wallach contributed an integration with Arlo to enable ElectionGuard to provide the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election.  </p> <p>Last, and definitely not least, ElectionGuard developed and published its first independent verifiers.</p>"},{"location":"overview/Roadmap/#2020-roadmap","title":"2020 Roadmap","text":"Use ElectionGuard in a real-world end-to-end verifiable election <ul> <li>Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site.</li> <li>Integrate ElectionGuard with the VotingWorks print station and user flow</li> <li>Build ballot box functionality to capture and seal ballots</li> <li>Build admin device to enable tallies and key ceremonies</li> <li>Build tracking site to enable verification code lookup and tally/results download</li> </ul> Use ElectionGuard in a real-world post-election audit <ul> <li>Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end</li> <li>Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits</li> </ul> Update the ElectionGuard Specification to 1.0.0-preview-1 Support building ElectionGuard into additional voting systems <ul> <li>Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives</li> <li>Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions</li> </ul> Release and iterate on <code>electionguard-python</code> as a core implementation that meets specification 1.0.0-preview-1 <ul> <li>Implement a canonical library addressing all ElectionGuard SDK functionality:</li> <li>Key generation</li> <li>Ballot encryption</li> <li>Ballot sealing </li> <li>Tally generation</li> <li>Verifier specification</li> <li>Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation)</li> </ul> Integrate ElectionGuard into a set of election tools"},{"location":"overview/Roadmap/#2019-roadmap","title":"2019 Roadmap","text":"Initial specification and <code>electionguard-c</code> release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference"},{"location":"spec/","title":"ElectionGuard Official Specifications","text":"<p>The official versions of the ElectionGuard Specifications are listed below and stand as the primary source of reference when discussing the ElectionGuard Specification. Each version includes a badge that can be used to quickly display which versions are supported or used by products following the specification. To follow along with the code versioning, see the versioning.</p> Version Specification Recommended Badge 2.1  Download 2.0  Download 1.1  Download 1.0  Download 0.95  Download 0.85  Download"},{"location":"spec/#release-notes","title":"Release Notes","text":""},{"location":"spec/#v21","title":"v2.1","text":"<p>Version 2.1 of the ElectionGuard Design Specification has been significantly extended compared to version 2.0.0 and contains several significant changes.</p> <ul> <li>Key generation: Three sets of keys are now generated by the guardians in order to support distinct uses; and a guardian record has been created, which the guardians must verify at the end of the key generation process.</li> <li>Ballot preparation: a selection encryption identifier is now created for each ballot, which is used to link together all the ciphertexts and proofs associated to a single ballot; signed ElGamal is now used for encrypting all data other than voter selections; the ballot nonce must now be encrypted and included in each ballot.</li> <li>Confirmation codes: A voting device information hash has been added; the simple ballot chaining mode has been detailed and refined.</li> <li>Tallying operations: Guardians now verify the election record before starting the tallying operations; support for weighting ballots during aggregation has been added; the verifiable decryption process and protocols have been detailed and updated.</li> <li>Audit of challenged ballots: The opening of challenged ballots has been made more efficient by releasing relevant encryption nonces instead of performing verifiable decryption.</li> <li>Hash computation steps have been revised and updated in many places, and a hash function that maps to integers modulo q has been defined separately.</li> <li>Several components have been designated as optional such as supplemental verifiable fields, contest data, and pre-encrypted ballots.</li> <li>A concrete list of verification steps for pre-encrypted ballots has been added.</li> </ul>"},{"location":"spec/#v20","title":"v2.0","text":"<p>2.0 is a major refactor of the ElectionGuard specification. It includes the following capabilities</p> <ul> <li>The size of the proofs in the election record has been reduced by more than 90% \u2013 reducing the size of the full election record by about a factor of 3.</li> <li>Computing the proofs takes about 20% less time.</li> <li>Placeholder selections have been eliminated entirely.</li> <li>Guardians are no longer part of the election record as their partial decryptions and proofs have been administratively combined into single full decryptions and proofs.</li> <li>Range proofs are now included to support voting systems like cumulative voting, range voting, STAR-voting, Borda count, and others.</li> <li>A new pre-encrypted ballot format is included to support vote-by-mail, central count, and paper-only poll sites.</li> <li>Support is now available for instant verification allowing voters to confirm the accuracy of challenge ballots without waiting for the election record to be published.</li> <li>New default parameters are used with ln(2) replacing the Euler-Mascheroni constant as the basis for generation of the large prime.</li> <li>The data format of hashes has been clearly described to eliminate ambiguities.</li> </ul>"},{"location":"spec/#v10","title":"v1.0","text":"<p>Updates from previous version</p> <ul> <li>The large prime p and corresponding cofactor r were changed to correctly match the result of the process for the derivation of the prime.</li> <li>The equations for generating proofs of ballot correctness have been optimized.</li> <li>Auxiliary keys have been eliminated in favor of using the existing keys for both ordinary and exponential ElGamal encryption.</li> <li>A more flexible structure of ballot chaining has been introduced to allow for non-linear chaining or no chaining at all.</li> <li>Smaller parameters suitable for testing are included.</li> <li>The election record of this version should match that of the prior v0.95 and therefore require no verifier changes (with the exception of using the corrected prime).</li> </ul>"},{"location":"spec/#v095","title":"v0.95","text":"<p>Updates from previous version</p> <ul> <li>The large prime p and corresponding cofactor r were changed to move the prime p further from 2^4096.</li> <li>A section specifically about writing verifiers was added.</li> <li>Various small clarifications and corrections were included.</li> </ul>"},{"location":"spec/#v085","title":"v0.85","text":"<ul> <li>Initial public release of specification for ElectionGuard</li> </ul>"},{"location":"spec/Serialization_Spec/","title":"ElectionGuard Serialization Specification","text":"<p>This specification exists to help anyone trying to write a compatible implementation or, crucially, anyone trying to write a verifier. The design says what has to be done, how, and why. The data serialization spec describes the data formats used in the implementation to achieve the design. The data serialization spec currently matches the v2.0 implementation.</p> Version Specification Recommended Compatible EG Spec 0.0.1  Download"},{"location":"use_cases/Precinct_Scan/","title":"Precinct Scan","text":"<p>Work in Progress</p> <p>This is a work in progress. Feel free to contribute.</p>"},{"location":"use_cases/Precinct_Scan/#overview","title":"Overview","text":"<p>By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly <sup>1</sup>.</p> <p>This document aims to provide a \"vertical slice\" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability. In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system.</p> <p>Info</p> <p>ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of end-to-end verifiability.</p> <p>For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation.</p> <p>ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner.</p> <p>End-to-end verifiability mandates that these challenged ballots, unlike cast ballots, be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election record have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were.</p> <p>When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate.</p> <p>Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges).</p> <p>This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice.</p>"},{"location":"use_cases/Precinct_Scan/#current-precinct-scan-voter-experience","title":"Current Precinct Scan Voter Experience","text":"<p>A typical voter flow for a precinct scan system is illustrated below.</p> <p>After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record, an electronic representation of the voter's selections.</p> <p>If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth.</p> <p>If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot.</p> <p>The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter.</p>"},{"location":"use_cases/Precinct_Scan/#adapting-precinct-scan-for-end-to-end-verifiability-e2e-v","title":"Adapting Precinct Scan for End-to-end Verifiability (E2E-V)","text":""},{"location":"use_cases/Precinct_Scan/#voter-experience","title":"Voter Experience","text":"<p>As outlined in the Verifiable Election page of the ElectionGuard SDK <sup>2</sup>, for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter:</p> <ul> <li>immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony)</li> <li>present the verification code generated by the encryption to the voter (ideally in paper format)</li> <li>present the means for the voter to cast or challenge (spoil) the ballot</li> </ul>"},{"location":"use_cases/Precinct_Scan/#technical-requirements","title":"Technical Requirements","text":"<p>For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments.</p>"},{"location":"use_cases/Precinct_Scan/#technical-implementation","title":"Technical Implementation","text":""},{"location":"use_cases/Precinct_Scan/#overview-and-operational-assumptions","title":"Overview and Operational Assumptions","text":"<p>Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions.</p> <p>To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key.</p> <p>Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.)</p>"},{"location":"use_cases/Precinct_Scan/#general-election-setup","title":"General Election Setup","text":"<p>Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state.</p> <p>Election setup generally consists of preparing the voting machines for the current election contests, running any pre-production testing, and final configuration for election readiness.</p> <p>For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (the scanner is assumed to be entirely offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation.</p> <p>In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election.</p>"},{"location":"use_cases/Precinct_Scan/#ballot-manifest","title":"Ballot manifest","text":"<p>Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria. ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created.</p> <p>Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well.</p>"},{"location":"use_cases/Precinct_Scan/#public-encryption-key","title":"Public encryption key","text":"<p>One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of the election record. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections.</p> <p>As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The</p>"},{"location":"use_cases/Precinct_Scan/#logic-and-accuracy-testing","title":"Logic and Accuracy Testing","text":""},{"location":"use_cases/Precinct_Scan/#scanner-final-production-setup","title":"Scanner Final Production Setup","text":""},{"location":"use_cases/Precinct_Scan/#launch-code","title":"Launch Code","text":""},{"location":"use_cases/Precinct_Scan/#scanner-election-operation","title":"Scanner Election Operation","text":""},{"location":"use_cases/Precinct_Scan/#ballot-encryption","title":"Ballot Encryption","text":""},{"location":"use_cases/Precinct_Scan/#generation-of-verification-code","title":"Generation of Verification Code","text":""},{"location":"use_cases/Precinct_Scan/#ballot-chaining","title":"Ballot Chaining","text":""},{"location":"use_cases/Precinct_Scan/#ballot-dehydration","title":"Ballot Dehydration","text":""},{"location":"use_cases/Precinct_Scan/#dehydrated-ballot-structure","title":"Dehydrated ballot structure","text":"<p>A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability.</p> Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process"},{"location":"use_cases/Precinct_Scan/#ballot-finalization","title":"Ballot Finalization","text":""},{"location":"use_cases/Precinct_Scan/#cast-ballots","title":"Cast ballots","text":""},{"location":"use_cases/Precinct_Scan/#challenge-ballots","title":"Challenge ballots","text":"<ol> <li> <p>As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9</p> </li> <li> <p>ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/]\u00a0\u21a9</p> </li> </ol>"},{"location":"use_cases/Rescans_and_Recounts/","title":"Rescans and Recounts","text":"<p>Warning</p> <p>This is a documented but not currently implemented capability. See the Roadmap for implementation details and status.</p>"},{"location":"use_cases/Rescans_and_Recounts/#overview","title":"Overview","text":"<p>In the course of an election with paper ballots, occasions may arise when all or some of the ballots in an election may need to be rescanned without being in the presence of the voter.</p> <p>For example, if a precinct scanner fails on election day, some municipalities may require a new scanner to be activated and the ballots scanned through the failed scanner to be re-scanned in the new scanner; those rescans would likely not be conducted in the presence of the affected voters, and the verification codes generated from the subsequent scans would not be available to them.</p> <p>Similarly, some elections require multiple recounts, including hand tallies, to resolve challenges or recounts triggered by narrow margins of victory. Ballots may be included or excluded from subsequent recounts dependent on the interpretation of the scans or their inclusion or exclusion in the the subsequent tallies.</p> <p>Info</p> <p>Depending on how the ballot is encrypted (such as whether ballot-chaining is being used), the verification codes generated in the rescan would not be the same. The \"default\" implementation of ElectionGuard, which uses the unique ID of the device performing the encryption as part of the encryption itself, would generate a different verification code if the same ballot is scanned on a different device. If ballot-chaining or any time-based component were included in the encryption, even subsequent scans of the same ballot on the same scanner would generate a different verification code.</p> <p>When a voter checks whether their ballot was included in the ElectionGuard published artifacts, the information should reflect whether the ballot was included (and even more importantly not included) in any subsequent tallies published by the election administration. This must be accomplished without undermining the core integrity and privacy concerns of the verification processes.</p> <p>Warning</p> <p>The proposed process mandates a unique ballot identifier be generated by the host voting system (not ElectionGuard), printed on the ballot, and captured as part of the ElectionGuard metadata.</p>"},{"location":"use_cases/Rescans_and_Recounts/#proposed-approach","title":"Proposed Approach","text":"<p>To maintain the security and integrity of the original election record, rescans and recounts are guardian-based processes. This requirement presents potentially significant additional compute both for the local guardian device / hardware security module and any cloud-based approach to scale the cross-tally mapping.</p>"},{"location":"use_cases/Rescans_and_Recounts/#encrypting-a-unique-ballot-id","title":"Encrypting a Unique Ballot ID","text":"<p>Since a rescan or recount can occur on any independent device, the information for mapping must be present on and derived from the paper ballot itself. Specifically, in addition to all the contests and candidates, there must be an ID unique to the election printed on the ballot. When scanned by the scanner, that ID is included in the encrypted ballot metadata encrypted by the auxiliary guardian RSA key separate from the El Gamal encryption<sup>1</sup> used for the ballot contents.</p> <p>Alert</p> <p>Municipalities that do not allow the printing of unique identifiers on their paper ballots cannot use ElectionGuard for the rescan scenario, since there is no way to perform any mapping across independent tallies</p>"},{"location":"use_cases/Rescans_and_Recounts/#diffing-an-election","title":"Diffing an Election","text":""},{"location":"use_cases/Rescans_and_Recounts/#invoking-a-rescan-or-recount","title":"Invoking a Rescan or Recount","text":"<p>After the base ElectionGuard verifiable tally has been generated (and, optionally, published) a rescan or recount can be performed.</p>"},{"location":"use_cases/Rescans_and_Recounts/#optimizing-the-compute","title":"Optimizing the Compute","text":"<ol> <li> <p>Because the primary joint public key is an ElGamal key, it is optimized for the ones and zeroes that constitute the contents of a ballot, not the generic string values necessary to support arbitrary IDs.\u00a0\u21a9</p> </li> </ol>"}]}